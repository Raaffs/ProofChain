package zkp

import (
	"slices"
	"sort"

	"github.com/Suy56/ProofChain/storage/models"
)

// MerkleProof implements the ZKProof interface and holds the committed data state.
type MerkleProof struct {
	RootHash   Hash
	FieldLeaves map[string]FieldLeaf // Map for O(1) lookup during Disclosure
	LeafHashes []Hash                // Ordered list for Merkle Tree construction
}

func NewMerkleProof() *MerkleProof {
	mp:=&MerkleProof{}
	mp.New()
	return mp
}

func (id *MerkleProof) New()  {
	id.RootHash = ""
	id.FieldLeaves = make(map[string]FieldLeaf)
	id.LeafHashes = make([]Hash, 0)
}

// GenerateRootProof (Issuer side)
func (id *MerkleProof) GenerateRootProof(c models.CertificateData) (Hash, SaltedCertificate, error) {
	// 1. Salt the fields
	saltedCert, err := SaltCertificate(c)
	if err != nil {
		return "", SaltedCertificate{}, err
	}

	// 2. Prepare state for Merkle Tree generation (keys must be sorted for deterministic ordering)
	var keys []string
	for key := range saltedCert.SaltedFields {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	id.FieldLeaves = saltedCert.SaltedFields
	id.LeafHashes = make([]Hash, 0, len(keys))

	// 3. Build the ordered LeafHashes list
	for _, key := range keys {
		leaf := id.FieldLeaves[key]
		id.LeafHashes = append(id.LeafHashes, leaf.Hash)
	}

	// 4. Calculate Merkle Root
	id.RootHash = calculateMerkleRoot(id.LeafHashes)

	// The Issuer sends the Root Hash (to Blockchain) and the SaltedCertificate (to Requestor)
	return id.RootHash, saltedCert, nil
}


// --- Verification Helper (Verifier Logic) ---

// VerifyProof checks if a disclosed proof matches the expected root hash.
// This runs on the client/verifier side.
func VerifyProof(p Proof, expectedRoot Hash) bool {
    //Re-calculate the leaf hash for the field we are checking
    disclosedLeafHash := HashData([]byte(p.Value), []byte(p.Salt))
    
	//check if disclosed hash are present in the hash fields user provided
    found := slices.Contains(p.MerkleProof, disclosedLeafHash)
    
    if !found {
        // If the hash isn't in the list, the user is passing invalid proof 
        return false 
    }

    // Re-calculate the root 
    calculatedRoot := calculateMerkleRoot(p.MerkleProof)

    // Verify
    return calculatedRoot == expectedRoot && calculatedRoot == p.RootHash
}

// calculateMerkleRoot calculates the root hash from an ordered list of leaf hashes.
func calculateMerkleRoot(leaves []Hash) Hash {
	if len(leaves) == 0 {
		return ""
	}
	if len(leaves) == 1 {
		return leaves[0]
	}

	// Pad if odd
	currentLeaves := make([]Hash, len(leaves))
	copy(currentLeaves, leaves)
	if len(currentLeaves)%2 != 0 {
		currentLeaves = append(currentLeaves, currentLeaves[len(currentLeaves)-1])
	}

	var nextLevel []Hash
	for i := 0; i < len(currentLeaves); i += 2 {
		h1 := currentLeaves[i]
		h2 := currentLeaves[i+1]
		// Sort hashes before concatenating to ensure canonical parent hash
		if h1 < h2 {
			nextLevel = append(nextLevel, HashData([]byte(h1), []byte(h2)))
		} else {
			nextLevel = append(nextLevel, HashData([]byte(h2), []byte(h1)))
		}
	}

	return calculateMerkleRoot(nextLevel)
}

